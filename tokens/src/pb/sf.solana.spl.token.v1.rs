// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Events {
    #[prost(message, repeated, tag="1")]
    pub data: ::prost::alloc::vec::Vec<Event>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(string, tag="101")]
    pub txn_id: ::prost::alloc::string::String,
    #[prost(uint64, tag="102")]
    pub block_height: u64,
    #[prost(int64, tag="103")]
    pub block_timestamp: i64,
    #[prost(string, tag="104")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(uint32, tag="106")]
    pub instruction_index: u32,
    #[prost(oneof="event::Type", tags="10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 23, 24")]
    pub r#type: ::core::option::Option<event::Type>,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag="10")]
        Transfer(super::Transfer),
        #[prost(message, tag="11")]
        InitializeMint(super::InitializeMint),
        #[prost(message, tag="12")]
        InitializeImmutableOwner(super::InitializeImmutableOwner),
        #[prost(message, tag="13")]
        InitializeAccount(super::InitializeAccount),
        #[prost(message, tag="14")]
        InitializeMultisig(super::InitializeMultisig),
        #[prost(message, tag="15")]
        Approve(super::Approve),
        #[prost(message, tag="16")]
        MintTo(super::MintTo),
        #[prost(message, tag="17")]
        Revoke(super::Revoke),
        #[prost(message, tag="18")]
        SetAuthority(super::SetAuthority),
        #[prost(message, tag="19")]
        Burn(super::Burn),
        #[prost(message, tag="20")]
        CloseAccount(super::CloseAccount),
        #[prost(message, tag="22")]
        FreezeAccount(super::FreezeAccount),
        #[prost(message, tag="23")]
        ThawAccount(super::ThawAccount),
        #[prost(message, tag="24")]
        SyncNative(super::SyncNative),
    }
}
/// The instructions 'Transfer' and 'TransferChecked' are both represented by this message.
/// You can check if the instructions was 'TransferChecked' by inspecting the 'accounts.token_mint',
/// if set, it was a 'TransferChecked' instruction.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transfer {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<transfer::TransferInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<transfer::TransferAccounts>,
}
/// Nested message and enum types in `Transfer`.
pub mod transfer {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct TransferInstruction {
        #[prost(uint64, tag="1")]
        pub amount: u64,
        /// Only set if the instruction was 'TransferChecked'
        #[prost(uint32, optional, tag="2")]
        pub decimals: ::core::option::Option<u32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransferAccounts {
        #[prost(string, tag="1")]
        pub source: ::prost::alloc::string::String,
        /// Only set if the instruction was 'TransferChecked'
        #[prost(string, optional, tag="2")]
        pub token_mint: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, tag="3")]
        pub destination: ::prost::alloc::string::String,
        #[prost(message, optional, tag="4")]
        pub signer: ::core::option::Option<super::Signer>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeMint {
    #[prost(enumeration="initialize_mint::InitializeMintVersion", tag="1")]
    pub version: i32,
    #[prost(message, optional, tag="2")]
    pub instruction: ::core::option::Option<initialize_mint::InitializeMintInstruction>,
    #[prost(message, optional, tag="3")]
    pub accounts: ::core::option::Option<initialize_mint::InitializeMintAccounts>,
}
/// Nested message and enum types in `InitializeMint`.
pub mod initialize_mint {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InitializeMintInstruction {
        #[prost(uint32, tag="1")]
        pub decimals: u32,
        #[prost(string, tag="2")]
        pub mint_authority: ::prost::alloc::string::String,
        #[prost(string, optional, tag="3")]
        pub freeze_authority: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InitializeMintAccounts {
        #[prost(string, tag="1")]
        pub mint: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum InitializeMintVersion {
        Unspecified = 0,
        V1 = 1,
        V2 = 2,
    }
    impl InitializeMintVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InitializeMintVersion::Unspecified => "UNSPECIFIED",
                InitializeMintVersion::V1 => "V1",
                InitializeMintVersion::V2 => "V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "V1" => Some(Self::V1),
                "V2" => Some(Self::V2),
                _ => None,
            }
        }
    }
}
/// The instructions 'InitializeAccount', 'InitializeAccount2' and 'InitializeAccount3'
/// are all represented by this message. The 'InitializeAccount2'
/// instruction's which has pubkey in isntruction is mapped to
/// `accoubts.owner` like in the V1 case. The V3 case is that same as V2 without the
/// rent account that we don't track.
///
/// You can use the `version` field (1 or 2) to determine which instruction
/// is being used.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeAccount {
    #[prost(enumeration="initialize_account::InitializeAccountVersion", tag="1")]
    pub version: i32,
    #[prost(message, optional, tag="2")]
    pub instruction: ::core::option::Option<initialize_account::InitializeAccountInstruction>,
    #[prost(message, optional, tag="3")]
    pub accounts: ::core::option::Option<initialize_account::InitializeAccountAccounts>,
}
/// Nested message and enum types in `InitializeAccount`.
pub mod initialize_account {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InitializeAccountInstruction {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InitializeAccountAccounts {
        #[prost(string, tag="1")]
        pub account: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub mint: ::prost::alloc::string::String,
        #[prost(string, tag="3")]
        pub owner: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum InitializeAccountVersion {
        Unspecified = 0,
        V1 = 1,
        V2 = 2,
        V3 = 3,
    }
    impl InitializeAccountVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InitializeAccountVersion::Unspecified => "UNSPECIFIED",
                InitializeAccountVersion::V1 => "V1",
                InitializeAccountVersion::V2 => "V2",
                InitializeAccountVersion::V3 => "V3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "V1" => Some(Self::V1),
                "V2" => Some(Self::V2),
                "V3" => Some(Self::V3),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeMultisig {
    #[prost(enumeration="initialize_multisig::InitializeMultisigVersion", tag="1")]
    pub version: i32,
    #[prost(message, optional, tag="2")]
    pub instruction: ::core::option::Option<initialize_multisig::InitializeMultisigInstruction>,
    #[prost(message, optional, tag="3")]
    pub accounts: ::core::option::Option<initialize_multisig::InitializeMultisigAccounts>,
}
/// Nested message and enum types in `InitializeMultisig`.
pub mod initialize_multisig {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InitializeMultisigInstruction {
        /// The number of signers required to approve transactions, equivalent to `m` in SPL Token
        #[prost(uint32, tag="1")]
        pub signature_count_threshold: u32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InitializeMultisigAccounts {
        #[prost(string, tag="1")]
        pub account: ::prost::alloc::string::String,
        #[prost(string, repeated, tag="2")]
        pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum InitializeMultisigVersion {
        Unspecified = 0,
        V1 = 1,
        V2 = 2,
    }
    impl InitializeMultisigVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InitializeMultisigVersion::Unspecified => "UNSPECIFIED",
                InitializeMultisigVersion::V1 => "V1",
                InitializeMultisigVersion::V2 => "V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "V1" => Some(Self::V1),
                "V2" => Some(Self::V2),
                _ => None,
            }
        }
    }
}
/// The instructions 'Approve' and 'ApproveChecked' are both represented by this message.
/// You can check if the instructions was 'ApproveChecked' by inspecting the 'accounts.token_mint',
/// if set, it was a 'ApproveChecked' instruction.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Approve {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<approve::ApproveInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<approve::ApproveAccounts>,
}
/// Nested message and enum types in `Approve`.
pub mod approve {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ApproveInstruction {
        #[prost(uint64, tag="1")]
        pub amount: u64,
        /// Only set if the instruction was 'ApproveChecked'
        #[prost(uint32, optional, tag="2")]
        pub decimals: ::core::option::Option<u32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ApproveAccounts {
        #[prost(string, tag="1")]
        pub source: ::prost::alloc::string::String,
        /// Only set if the instruction was 'ApproveChecked'
        #[prost(string, optional, tag="2")]
        pub token_mint: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, tag="3")]
        pub delegate: ::prost::alloc::string::String,
        #[prost(message, optional, tag="4")]
        pub signer: ::core::option::Option<super::Signer>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Revoke {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<revoke::RevokeInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<revoke::RevokeAccounts>,
}
/// Nested message and enum types in `Revoke`.
pub mod revoke {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RevokeInstruction {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RevokeAccounts {
        #[prost(string, tag="1")]
        pub source: ::prost::alloc::string::String,
        #[prost(message, optional, tag="2")]
        pub signer: ::core::option::Option<super::Signer>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAuthority {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<set_authority::SetAuthorityInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<set_authority::SetAuthorityAccounts>,
}
/// Nested message and enum types in `SetAuthority`.
pub mod set_authority {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetAuthorityInstruction {
        #[prost(enumeration="AuthorityType", tag="1")]
        pub authority_type: i32,
        #[prost(string, optional, tag="2")]
        pub new_authority: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetAuthorityAccounts {
        #[prost(string, tag="1")]
        pub account: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub current_authority: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum AuthorityType {
        AuthorityNull = 0,
        AuthorityMintTokens = 1,
        AuthorityFreezeAccount = 2,
        AuthorityAccountOwner = 3,
        AuthorityCloseAccount = 4,
    }
    impl AuthorityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AuthorityType::AuthorityNull => "AuthorityNull",
                AuthorityType::AuthorityMintTokens => "AuthorityMintTokens",
                AuthorityType::AuthorityFreezeAccount => "AuthorityFreezeAccount",
                AuthorityType::AuthorityAccountOwner => "AuthorityAccountOwner",
                AuthorityType::AuthorityCloseAccount => "AuthorityCloseAccount",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AuthorityNull" => Some(Self::AuthorityNull),
                "AuthorityMintTokens" => Some(Self::AuthorityMintTokens),
                "AuthorityFreezeAccount" => Some(Self::AuthorityFreezeAccount),
                "AuthorityAccountOwner" => Some(Self::AuthorityAccountOwner),
                "AuthorityCloseAccount" => Some(Self::AuthorityCloseAccount),
                _ => None,
            }
        }
    }
}
/// The instructions 'MintTo' and 'MintToChecked' are both represented by this message.
/// You can check if the instructions was 'MintToChecked' by inspecting the
/// 'instruction.decimals' field. If set, it was a 'MintToChecked' instruction.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MintTo {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<mint_to::MintToInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<mint_to::MintToAccounts>,
}
/// Nested message and enum types in `MintTo`.
pub mod mint_to {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct MintToInstruction {
        #[prost(uint64, tag="1")]
        pub amount: u64,
        /// Only set if the instruction was 'MintToChecked'
        #[prost(uint32, optional, tag="2")]
        pub decimals: ::core::option::Option<u32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MintToAccounts {
        #[prost(string, tag="1")]
        pub mint: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub destination: ::prost::alloc::string::String,
        #[prost(message, optional, tag="3")]
        pub mint_authority: ::core::option::Option<super::Signer>,
    }
}
/// The instructions 'Burn' and 'BurnChecked' are both represented by this message.
/// You can check if the instructions was 'BurnChecked' by inspecting the
/// 'instruction.decimals' field. If set, it was a 'BurnChecked' instruction.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Burn {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<burn::BurnInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<burn::BurnAccounts>,
}
/// Nested message and enum types in `Burn`.
pub mod burn {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BurnInstruction {
        #[prost(uint64, tag="1")]
        pub amount: u64,
        /// Only set if the instruction was 'BurnChecked'
        #[prost(uint32, optional, tag="2")]
        pub decimals: ::core::option::Option<u32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BurnAccounts {
        #[prost(string, tag="1")]
        pub source: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub mint: ::prost::alloc::string::String,
        #[prost(message, optional, tag="3")]
        pub signer: ::core::option::Option<super::Signer>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloseAccount {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<close_account::CloseAccountInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<close_account::CloseAccountAccounts>,
}
/// Nested message and enum types in `CloseAccount`.
pub mod close_account {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CloseAccountInstruction {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CloseAccountAccounts {
        #[prost(string, tag="1")]
        pub account: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub destination: ::prost::alloc::string::String,
        #[prost(message, optional, tag="3")]
        pub signer: ::core::option::Option<super::Signer>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FreezeAccount {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<freeze_account::FreezeAccountInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<freeze_account::FreezeAccountAccounts>,
}
/// Nested message and enum types in `FreezeAccount`.
pub mod freeze_account {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FreezeAccountInstruction {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FreezeAccountAccounts {
        #[prost(string, tag="1")]
        pub account: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub mint: ::prost::alloc::string::String,
        #[prost(message, optional, tag="3")]
        pub mint_freeze_authority: ::core::option::Option<super::Signer>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThawAccount {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<thaw_account::ThawAccountInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<thaw_account::ThawAccountAccounts>,
}
/// Nested message and enum types in `ThawAccount`.
pub mod thaw_account {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ThawAccountInstruction {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ThawAccountAccounts {
        #[prost(string, tag="1")]
        pub account: ::prost::alloc::string::String,
        #[prost(string, tag="2")]
        pub mint: ::prost::alloc::string::String,
        #[prost(message, optional, tag="3")]
        pub mint_freeze_authority: ::core::option::Option<super::Signer>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitializeImmutableOwner {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<initialize_immutable_owner::InitializeImmutableOwnerInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<initialize_immutable_owner::InitializeImmutableOwnerAccounts>,
}
/// Nested message and enum types in `InitializeImmutableOwner`.
pub mod initialize_immutable_owner {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InitializeImmutableOwnerInstruction {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InitializeImmutableOwnerAccounts {
        #[prost(string, tag="1")]
        pub account: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncNative {
    #[prost(message, optional, tag="1")]
    pub instruction: ::core::option::Option<sync_native::SyncNativeInstruction>,
    #[prost(message, optional, tag="2")]
    pub accounts: ::core::option::Option<sync_native::SyncNativeAccounts>,
}
/// Nested message and enum types in `SyncNative`.
pub mod sync_native {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SyncNativeInstruction {
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SyncNativeAccounts {
        #[prost(string, tag="1")]
        pub native_token_account: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signer {
    #[prost(oneof="signer::Kind", tags="1, 2")]
    pub kind: ::core::option::Option<signer::Kind>,
}
/// Nested message and enum types in `Signer`.
pub mod signer {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag="1")]
        Single(super::SingleSignature),
        #[prost(message, tag="2")]
        Multisig(super::MultiSignature),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SingleSignature {
    #[prost(string, tag="1")]
    pub signer: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MultiSignature {
    #[prost(string, tag="1")]
    pub multisig_account: ::prost::alloc::string::String,
    #[prost(string, repeated, tag="2")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
// @@protoc_insertion_point(module)
